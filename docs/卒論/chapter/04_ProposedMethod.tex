\chapter{提案手法}
本章では，PGD攻撃の初期化にDeepFoolの境界情報を活用する手法を提案する．この手法の目的は，PGD攻撃の収束を早める可能性を検証することである．

\section{DeepFool初期化の動機}
\label{sec:motivation}

\subsection{PGD攻撃の初期化の重要性}
PGD攻撃は\ref{sec:pgd}節で述べたように，制約範囲内で損失を最大化する方向に反復的に摂動を更新する手法である．ランダム初期化PGDでは，$\ell_\infty$制約範囲内の一様乱数点から攻撃を開始する．この初期点は損失関数の形状やラベル境界の位置とは無関係にランダムに選ばれるため，必ずしも効率的な探索開始点とは限らない．

一方，DeepFoolは\ref{sec:deepfool}節で述べたように，最も近いラベル境界へ向かう方向に摂動を更新することで敵対的サンプルを生成する．DeepFoolが見つけた敵対的サンプルはラベル境界付近に位置しており，この境界情報をPGD攻撃の初期化に活用することで，より効率的な探索が可能になると考えられる．

\subsection{期待される効果}
DeepFool初期化により，以下の効果が期待される：
\begin{itemize}
    \item ラベル境界付近から探索を開始することで，損失が高い領域への到達が早まる可能性
    \item 少ない反復回数でプラトー（損失の収束領域）に到達できる可能性
\end{itemize}

\section{DeepFool初期化の手順}
本節では，DeepFool初期化の具体的な手順を説明する．

\subsection{DeepFoolによる敵対的サンプルの生成}
まず，入力画像$x$に対してDeepFoolを適用し，敵対的サンプル$x_{\text{df}}$を生成する．DeepFoolの更新式は式(\ref{eq:deepfool})で示した通りであり，パラメータとして最大反復回数$T_{\text{df}}$とオーバーシュート係数$\eta$を設定する．本研究では$T_{\text{df}} = 50$，$\eta = 0.02$を用いる．

\subsection{$\ell_\infty$制約への射影}
\label{sec:projection}
DeepFoolは$\ell_2$ノルム最小の摂動を求める手法であるため，得られた敵対的サンプル$x_{\text{df}}$はPGD攻撃の$\ell_\infty$制約を満たさない場合がある．そのため，$x_{\text{df}}$を$\ell_\infty$制約範囲に射影してPGDの初期点$x_{\text{init}}$を得る必要がある．

本研究では，成分毎クリッピングによる射影を用いる．DeepFoolによる敵対的サンプルの各成分を個別に$\ell_\infty$制約範囲にクリッピングする：
\begin{align}
    \{x_{\text{init}}\}_i = \text{clip}(\{x_{\text{df}}\}_i, \{x\}_i - \varepsilon, \{x\}_i + \varepsilon)
    \label{eq:clip}
\end{align}
ここで$\{\cdot\}_i$は$i$番目の成分を表す．この方法では，各成分が独立に制約範囲に収められる．

\subsection{PGD攻撃の実行}
射影後の初期点$x_{\text{init}}$から通常のPGD攻撃を開始する．更新式は式(\ref{eq:pgd})と同様であり，$x^0_{\text{adv}} = x_{\text{init}}$として反復を行う．

\section{Multi-DeepFool初期化}
\label{sec:multi_deepfool}
通常のDeepFoolは，現在の予測ラベルから最も近いラベルへ向かう摂動のみを考慮する．しかし，最も近いラベル以外のラベル境界の方向がPGD攻撃にとってより有利な初期点を与える可能性がある．

そこで，複数のターゲットラベルに対するDeepFoolを実行し，それぞれの結果を初期点として用いるMulti-DeepFool初期化を提案する．

\subsection{複数ターゲットへのDeepFool}
予測ラベル$y$以外の各ラベル$k \neq y$について，ラベル$k$を目標としたDeepFoolを実行する．ラベル$k$を目標とするDeepFoolでは，式(\ref{eq:deepfool})において$k^*_t = k$と固定して更新を行う：
\begin{align}
    r_{t,k} = -\frac{g_k(x_t)}{\|\nabla g_k(x_t)\|_2^2} \nabla g_k(x_t)
\end{align}
これにより，各ターゲットラベル$k$に対して敵対的サンプル$x^{(k)}_{\text{df}}$が得られる．

\subsection{最大損失選択}
各ターゲットラベルに対するDeepFool結果を$\ell_\infty$制約範囲に射影し，それぞれについて損失を計算する．その中で最も損失が大きい点をPGD攻撃の初期点として選択する：
\begin{align}
    x_{\text{init}} = \arg\max_{x^{(k)}_{\text{init}}} L(x^{(k)}_{\text{init}}, y)
\end{align}
ここで$x^{(k)}_{\text{init}}$は$x^{(k)}_{\text{df}}$を$\ell_\infty$制約範囲に射影した点である．

\section{提案手法の全体像}
\label{sec:overview}
DeepFool初期化によるPGD攻撃の全体の手順をAlgorithm \ref{alg:deepfool_init}に示す．

\begin{algorithm}[htbp]
\caption{DeepFool初期化によるPGD攻撃}
\label{alg:deepfool_init}
\begin{algorithmic}[1]
\REQUIRE 入力画像$x$，正解ラベル$y$，摂動制約$\varepsilon$，ステップサイズ$\alpha$，PGD反復回数$T_{\text{pgd}}$，DeepFoolパラメータ$(T_{\text{df}}, \eta)$
\ENSURE 敵対的サンプル$x_{\text{adv}}$
\STATE DeepFoolを適用して$x_{\text{df}}$を取得
\STATE $x_{\text{init}} \leftarrow$ $x_{\text{df}}$を$\ell_\infty$制約範囲にクリッピング（式(\ref{eq:clip})）
\STATE $x^0_{\text{adv}} \leftarrow x_{\text{init}}$
\FOR{$t = 0$ to $T_{\text{pgd}} - 1$}
    \STATE $x^{t+1}_{\text{adv}} \leftarrow \Pi_{x + \mathcal{S}} \left( x^t_{\text{adv}} + \alpha \cdot \text{sign}\left( \nabla_{x} L(x^t_{\text{adv}}, y) \right) \right)$
\ENDFOR
\RETURN $x^{T_{\text{pgd}}}_{\text{adv}}$
\end{algorithmic}
\end{algorithm}

\section{計算コストに関する考察}
\label{sec:computational_cost}

DeepFool初期化では，PGD攻撃の前にDeepFoolを実行する必要があるため，追加の計算コストが発生する．

\subsection{DeepFoolの計算コスト}
DeepFoolの計算量は主に勾配計算に由来する．各反復において，全てのラベル$k \neq y$について勾配$\nabla g_k(x)$を計算する必要がある．$K$クラス分類問題においては，1反復あたり$K-1$回の勾配計算が必要となる．DeepFoolの最大反復回数を$T_{\text{df}}$とすると，DeepFool単体での勾配計算回数は最大$(K-1) \cdot T_{\text{df}}$回となる．

MNISTおよびCIFAR10では$K = 10$であるため，$T_{\text{df}} = 50$の設定では最大450回の勾配計算が必要となる．

\subsection{Multi-DeepFoolの計算コスト}
Multi-DeepFool初期化では，$K-1$個のターゲットラベルそれぞれに対してDeepFoolを実行する．したがって，計算コストは通常のDeepFoolの約$K-1$倍となる．ただし，各ターゲットへのDeepFoolは独立に実行可能であるため，並列化による高速化が可能である．

\subsection{総計算コストの考察}
DeepFool初期化によりPGD攻撃の収束が早まれば，必要なPGDの反復回数を削減できる可能性がある．PGDの反復回数削減による計算コスト削減が，DeepFoolの追加コストを上回る場合，総計算量は減少し得る．この点については第\ref{chapter:experiment}章の実験結果に基づいて考察する．

